var documenterSearchIndex = {"docs":
[{"location":"functions.html#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions.html","page":"Functions","title":"Functions","text":"CurrentModule = MaterialModels","category":"page"},{"location":"functions.html","page":"Functions","title":"Functions","text":"initial_material_state\nget_cache\nupdate_cache!","category":"page"},{"location":"functions.html#MaterialModels.initial_material_state","page":"Functions","title":"MaterialModels.initial_material_state","text":"initial_material_state(::AbstractMaterial)\n\nReturn the MaterialState that belongs to the given Material and is initialized with zeros. \n\n\n\n\n\n","category":"function"},{"location":"functions.html#MaterialModels.get_cache","page":"Functions","title":"MaterialModels.get_cache","text":"get_cache(m::AbstractMaterial)\n\nConstruct cache object for iteratively solving non-linear material models.\n\nFor material models which require an iterative solution procedure, it is recommended to allocate storage for the iterative solver only once and reuse it for all material points. When multithreading is used, each threads needs its own cache.\n\n\n\n\n\n","category":"function"},{"location":"functions.html#MaterialModels.update_cache!","page":"Functions","title":"MaterialModels.update_cache!","text":"update_cache!(cache::OnceDifferentiable, f)\n\nUpdate the cache object with the residual function for the current time/load step.\n\nAs the residual functions depend i.a. on the strain increment, the function and its jacobian need to be updated for every load step.\n\n\n\n\n\n","category":"function"},{"location":"interface.html#Material-model-interface","page":"Material model interface","title":"Material model interface","text":"","category":"section"},{"location":"interface.html","page":"Material model interface","title":"Material model interface","text":"For fullfilling the AbstractMaterial interface, the following functions need to be defined:","category":"page"},{"location":"interface.html","page":"Material model interface","title":"Material model interface","text":"CurrentModule = MaterialModels","category":"page"},{"location":"interface.html","page":"Material model interface","title":"Material model interface","text":"AbstractMaterial\nAbstractMaterialState\nmaterial_response","category":"page"},{"location":"interface.html#MaterialModels.AbstractMaterial","page":"Material model interface","title":"MaterialModels.AbstractMaterial","text":"AbstractMaterial\n\nStore material parameters here. It can also be used to store constant precomputed properties, e.g. the elastic stiffness tensor. Ideally, the name should be chosen according to the first author of the initial publication of a model. For every Material there should be a keyword constructor and a list of arguments in the docstrings. If possible, also include the reference to a publication.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#MaterialModels.AbstractMaterialState","page":"Material model interface","title":"MaterialModels.AbstractMaterialState","text":"AbstractMaterialState\n\nStore state variables here. For now, this should not be mutable, a new object should be constructed for every new state. (We can discuss if this is a good or a bad idea.)\n\n\n\n\n\n","category":"type"},{"location":"interface.html#MaterialModels.material_response","page":"Material model interface","title":"MaterialModels.material_response","text":"material_response(m::AbstractMaterial, Δε::SymmetricTensor{2,3}, state::AbstractMaterialState, Δt; cache, options)\n\nCompute the stress, stress tangent and state variables for the given strain increment Δε and previous state state.\n\nInstead of the strain increment, the total strain could be handed over. Good ideas on how to handle this in general are welcome. For non-continuum kind of material models, the interface should be similar with stress-like and strain-like quantities. (E.g. for cohesive laws traction instead of stress and displacement jump instead of strain.) This function signature must be the same for all material models, even if they don't require all arguments.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Materials","page":"Materials","title":"Materials","text":"","category":"section"},{"location":"index.html","page":"Materials","title":"Materials","text":"LinearElastic\nmaterial_response(m::LinearElastic, Δε::SymmetricTensor{2,3}, state::LinearElasticState)\nPlastic\nmaterial_response(m::Plastic, Δε::SymmetricTensor{2,3,T,6}, state::PlasticState{3}; kwargs...) where T","category":"page"},{"location":"index.html#MaterialModels.LinearElastic","page":"Materials","title":"MaterialModels.LinearElastic","text":"LinearElastic(E, ν)\n\nIsotropic linear elasticity.\n\nArguments\n\nE::Float64: Young's modulus\nν::Float64: Poisson's ratio\n\n\n\n\n\n","category":"type"},{"location":"index.html#MaterialModels.material_response-Tuple{LinearElastic,SymmetricTensor{2,3,T,M} where M where T,LinearElasticState}","page":"Materials","title":"MaterialModels.material_response","text":"material_response(m::LinearElastic, ε::SymmetricTensor{2,3})\n\nReturn the stress tensor and the stress tangent for the given strain ε such that\n\nboldsymbolsigma = mathbfE^texte  boldsymbolvarepsilon \n\nNo MaterialState is needed for the stress computation, thus if a state is handed over to material_response, the same state is returned.\n\n\n\n\n\n","category":"method"},{"location":"index.html#MaterialModels.Plastic","page":"Materials","title":"MaterialModels.Plastic","text":"Plastic(E, ν, σ_y, H, r, κ_∞, α_∞)\n\nPlasticity with von Mises yield surface and mixed non-linear kinematic + non-linear isotropic hardening. Both hardening laws are of saturation type.\n\nArguments\n\nE::Float64: Young's modulus\nν::Float64: Poisson's ratio\nσ_y: yield limit\nH: hardening modulus\nr: coupling parameter between isotropic and kinematic hardening\nκ_∞: saturation stress for isotropic hardening\nα_∞: saturation stress for kinematic hardening\n\n\n\n\n\n","category":"type"},{"location":"index.html#MaterialModels.material_response-Union{Tuple{T}, Tuple{Plastic,SymmetricTensor{2,3,T,6},PlasticState{3,T,M} where M where T}} where T","page":"Materials","title":"MaterialModels.material_response","text":"material_response(m::Plastic, ε::SymmetricTensor{2,3,T,6}, state::PlasticState{3}; <keyword arguments>)\n\nReturn the stress tensor, stress tangent and the new MaterialState for the given strain ε and previous material state state.\n\nPlastic free energy:\n\nPsi^textp = frac12  r  H  k^2\n+ frac12left( 1-r right)  H  left sqrtfrac23 left textdev left(mathbfa right) right right^2\n\nVon Mises yield function:\n\nPhi = sqrtfrac32 left textdev left( boldsymbolsigma - boldsymbolalpha right) right - sigma_y - kappa\n\nAn associative flow rule and non-associative hardening rules are used. The evolution equations for the hardening variables are:\n\nbeginaligned\ndotk = -lambda left( 1 - frackappakappa_infty right) \ndotmathbfa = -lambda left( fracpartialPhipartialboldsymbolsigma \n+ frac32alpha_infty  textdev left( boldsymbolalpha right) right) \nendaligned\n\nKeyword arguments\n\ncache: Cache for the iterative solver, used by NLsolve.jl. It is strongly recommended to pre-allocate the cache for repeated calls to material_response. See get_cache.\noptions::Dict{Symbol, Any}: Solver options for the non-linear solver. Under the key :nlsolve_params keyword arguments for nlsolve can be handed over.\n\nSee NLsolve documentation. By default the Newton solver will be used.\n\n\n\n\n\n","category":"method"}]
}
